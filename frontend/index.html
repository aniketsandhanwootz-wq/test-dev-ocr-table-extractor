<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hybrid OCR & Manual Entry Tool</title>

    <!-- Handsontable CSS and JS from CDN -->
    <link rel="stylesheet" type="text/css"
        href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/hyperformula@2.6.2/dist/hyperformula.full.min.js"></script>

    <style>
        /* --------------------- Global & Container Styles --------------------- */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background: #0d0d0d;
            color: #ffffff;
            overflow: hidden;
            /* Prevent body scroll */
        }

        #hybrid-tool-container {
            width: 100%;
            max-width: 100%;
            /* reduced to allow Handsontable padding */
            max-height: 758px;
            background-color: #0d0d0d;
            padding: 0 24px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            /* Prevent horizontal scroll on container */
        }

        #main-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* --------------------- Top Row Controls --------------------- */
        #top-row-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-top: 16px;
            margin-bottom: 16px;
        }

        #tool-heading {
            font-size: 16px;
            font-weight: 500;
            color: #ffffff;
        }

        #top-row-right {
            display: flex;
            gap: 12px;
        }

        /* --------------------- Table Action Buttons --------------------- */
        #table-action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-bottom: 8px;
        }

        #table-action-buttons button {
            border: none;
            border-radius: 4px;
            padding: 6px 16px;
            font-size: 14px;
            cursor: pointer;
        }

        #extract-btn {
            background-color: #2b2a2a;
            color: #fff;
        }

        #submit-btn {
            background-color: #D89326;
            color: #fff;
            font-weight: 700;
        }

        /* --------------------- Table & OCR Wrapper --------------------- */
        #table-and-ocr-wrapper {
            display: flex;
            flex: 1;
            overflow: visible;
        }

        /* --------------------- Handsontable Area --------------------- */
        #handsontable-container {
            flex: 1 1 auto;
            min-width: 0;
            margin-right: 16px;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* Override cell borders to #444 */
        #handsontable-container .wtBorder {
            border-color: #444 !important;
        }

        /* Wrap long text in cells */
        .handsontable td .htCore {
            white-space: normal !important;
            word-break: break-word;
            /* allow long words or strings to wrap */
            overflow-wrap: break-word;
        }

        /* More specific class targeting */
        .handsontable textarea.handsontableInput,
        .handsontable input.handsontableInput {
            background-color: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #ccc !important;
        }

        .handsontable .htCore .htEditor {
            background-color: #ffffff !important;
        }

        .handsontable .wtHolder textarea,
        .handsontable .wtHolder input {
            background: #ffffff !important;
        }

        /* Instructions bar above the table */
        .instructions {
            background: #2b2a2a;
            /* border: 1px solid #444; */
            border-radius: 6px;
            padding: 8px 12px;
            /* margin-bottom: 12px; */
            font-size: 0.8rem;
            line-height: 1.3;
            color: #ccc;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            width: fit-content; /* Only as wide as content */
            position: absolute;
            left: 50%;
            top: 10px;
            transform: translateX(-50%); /* Perfect center */
            z-index: 1;
        }

        .instructions strong {
            color: #fff;
        }

        .help-icon {
            float: right;
            cursor: pointer;
            opacity: 0.7;
            position: relative;
            top: 0;
        }

        .help-icon:hover {
            opacity: 1;
        }

        .help-popover {
            position: fixed;
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            width: 50vw;
            max-width: none;
            min-width: none;
            margin-top: 8px;
            top: 100%; /* Below the help icon */
            left: 50%; /* Align to right edge of help icon */
            transform: translateX(-50%);
            display: none;
            color: #000;
        }
       
        .help-popover img {
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            max-height: 50vh; /* Prevent it from getting too tall */
            object-fit: contain; /* Maintain aspect ratio while fitting */        
            /* Remove the height restrictions I added */
        }       

        /* OCR Overlay Panel Styles */
        #ocr-panel {
            position: fixed;
            top: 5%;
            left: 5vw;
            width: 90vw;
            height: 80%;
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            display: none;
            flex-direction: column;
            color: #fff;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
        }

        #ocr-panel.open {
            display: flex;
        }

        #ocr-panel-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
            position: relative;
        }

        #ocr-close-btn {
            font-size: 20px;
            cursor: pointer;
            opacity: 0.7;
        }

        #ocr-close-btn:hover {
            opacity: 1;
        }       

        #ocr-panel-body {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .dark-label {
            font-size: 14px;
            margin-bottom: 4px;
            margin-top: 10px;
            text-align: center;
        }


        .upload-row {
        display: grid;
        grid-template-columns: 1.8fr 1fr 3.2fr 3.2fr; /* Part, Qty, Desc, Material */
        gap: 8px;
        width: 100%;
        box-sizing: border-box;
        }

        .upload-column {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 0; /* Allow shrinking */
        }


        .upload-icon {
            font-size: 24px;
            color: #666;
            margin-bottom: 8px;
            transition: color 0.2s ease;
        }

        .upload-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
            transition: color 0.2s ease;
        }


        .ocr-upload-area {
            border: 1.5px dashed #555;
            border-radius: 6px;
            padding: 6px;
            text-align: center;
            background: #2b2a2a;
            color: #000;
            position: relative;
            cursor: pointer;
            min-height: 180px;
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content when no image */
            align-items: center;
            transition: all 0.2s ease;
        }
 
.ocr-upload-area:hover {
    border: 1.5px solid #D89326 !important; /* Your specified color */
    background: #2b2a2a;
}

/* Drag over effect */
.ocr-upload-area.drag-over {
    border-color: #D89326;
    border-style: solid;
    background: #fff9f0;
    transform: scale(1.03);
    box-shadow: 0 4px 12px rgba(216, 147, 38, 0.2);
}

/* Active drag state */
.ocr-upload-area.drag-active {
    border-color: #D89326;
    border-width: 3px;
    background: #fff6e6;
}

.ocr-upload-area:hover .upload-icon,
.ocr-upload-area:hover .upload-label,
.ocr-upload-area.drag-over .upload-icon,
.ocr-upload-area.drag-over .upload-label,
.ocr-upload-area.drag-active .upload-icon
.ocr-upload-area.drag-active .upload-label {
    color: #D89326 !important;
}
      

        /* Only override when file is uploaded */
        .ocr-upload-area.has-file {
        justify-content: flex-start; /* Move to top when file uploaded */
        }

        /* Hide upload prompt when file is uploaded */
        .ocr-upload-area.has-file .upload-icon,
        .ocr-upload-area.has-file .upload-label {
        display: none;
        }        
        

        .upload-clear-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: rgba(108, 117, 125, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: all 0.2s ease;
            z-index: 2;
        }

        .upload-clear-btn:hover {
            background: rgb(218, 53, 51);
            transform: scale(1.1);
        }

        .ocr-upload-area.has-file .upload-clear-btn {
            display: flex;
        }

        .ocr-upload-area input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            z-index: 1;
        }

        .ocr-image-preview {
            width: 100%;
            max-height: none;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
            background-color: #222;
            margin-top: 6px;
        }

        .ocr-image-preview img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .file-status {
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 1px;
            color: #D89326;
            display: none;
        }

        .ocr-upload-area.has-file .file-status {
        display: block;
        }


        #ocr-process-btn {
            background-color: #D89326;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        }

        #ocr-process-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }

        /* Low similarity warning for dropdown cells */
        .low-similarity-cell {
            background-color: rgba(255, 193, 7, 0.3) !important;
            /* Yellow warning background */
            border: 1px solid #ffc107 !important;
            position: relative;
        }

        /* Warning icon for low similarity cells */
        .low-similarity-cell::after {
            content: "⚠️";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
        }

        /* --------------------- Responsive Behavior --------------------- */
        @media (max-width: 960px) {
            #table-and-ocr-wrapper {
                flex-direction: column;
            }

            /* Responsive positioning for #ocr-panel removed */
            #handsontable-container {
                margin-right: 0;
            }

            #top-row-right {
                flex-wrap: wrap;
                gap: 8px;
            }

            #top-row-right button {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div id="hybrid-tool-container">
        <div id="main-container">
            <!-- Top Row Controls -->
            <div id="top-row-controls">
                <!-- <div id="top-row-left">
          <span id="tool-heading">Add child parts/BO</span>
        </div> -->
                <!-- #top-row-right removed -->
            </div>

            <!-- Table and OCR Panel Wrapper -->
            <div id="table-and-ocr-wrapper">
                <!-- Handsontable Area (Left) -->
                <div id="handsontable-container">


                    <div id="table-action-buttons">
                        <button id="extract-btn">Extract</button>
                        <button id="submit-btn">Submit</button>
                    </div>
                    <!-- Handsontable placeholder (will be initialized via JS) -->
                    <div id="hot" style="width: 100%; height: 400px;"></div>
                </div>

                <!-- OCR Slide-In Panel (Right) -->
                <div id="ocr-panel">
                    <div id="ocr-panel-header">
                        <span id="ocr-close-btn">×</span>
                    </div>
                    <!-- Instructions bar above the table -->
                    <div class="instructions">
                        🔢 &lt; 20 rows | 🔍 zoom &amp; sharp | 🚫 no header
                        <span id="help-icon" class="help-icon"><i data-lucide="info"></i></span>
                        <div id="help-popover" class="help-popover">
                            <strong>Good vs Bad Screenshot:</strong><br />
                            <img src="sample-screenshot.png" style="width: 100%;" />
                        </div>
                    </div>


                    <div id="ocr-panel-body">
                        <div class="upload-row">
                            <div class="upload-column">
                                <label class="dark-label">Part Number</label>
                                <div class="ocr-upload-area" data-column="Part Number">
                                    <div class="upload-icon"><i data-lucide="upload"></i></div>
                                    <div class="upload-label">Upload Image</div>
                                    <button class="upload-clear-btn" onclick="clearUpload(this, event)">×</button>
                                    <input type="file" accept="image/*" />
                                    <div class="file-status">✓ Uploaded</div>
                                    <div class="ocr-image-preview"></div>
                                </div>
                            </div>
                            <div class="upload-column">
                                <label class="dark-label">Quantity</label>
                                <div class="ocr-upload-area" data-column="Quantity">
                                    <div class="upload-icon"><i data-lucide="upload"></i></div>
                                    <div class="upload-label">Upload Image</div>
                                    <button class="upload-clear-btn" onclick="clearUpload(this, event)">×</button>
                                    <input type="file" accept="image/*" />
                                    <div class="file-status">✓ Uploaded</div>
                                    <div class="ocr-image-preview"></div>
                                </div>
                            </div>
                            <div class="upload-column">
                                <label class="dark-label">Description</label>
                                <div class="ocr-upload-area" data-column="Description">
                                    <div class="upload-icon"><i data-lucide="upload"></i></div>
                                    <div class="upload-label">Upload Image</div>
                                    <button class="upload-clear-btn" onclick="clearUpload(this, event)">×</button>
                                    <input type="file" accept="image/*" />
                                    <div class="file-status">✓ Uploaded</div>
                                    <div class="ocr-image-preview"></div>
                                </div>
                            </div>
                            <div class="upload-column">
                                <label class="dark-label">Material</label>
                                <div class="ocr-upload-area" data-column="Material">
                                    <div class="upload-icon"><i data-lucide="upload"></i></div>
                                    <div class="upload-label">Upload Image</div>
                                    <button class="upload-clear-btn" onclick="clearUpload(this, event)">×</button>
                                    <input type="file" accept="image/*" />
                                    <div class="file-status">✓ Uploaded</div>
                                    <div class="ocr-image-preview"></div>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: flex-end; margin-top: 16px;">
                            <button id="ocr-process-btn" disabled>Process</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ——— Begin Existing JavaScript Logic ——— -->
    <!-- (These <script> blocks are your original logic, left completely intact. 
       They include renderSpreadsheet(), addColumn(), sendDataToBackend(), OCR calls, etc.) -->

    <script>
        // ─────────────────────────────────────────────────────────────────────
        // Global state & utility functions (unchanged from your original)
        // ─────────────────────────────────────────────────────────────────────

        let currentStep = 1; // (unused now that we've collapsed Step 1/2 into one hybrid view)
        // Column‐to‐Title mapping (used by renderSpreadsheet)
        const COLUMN_TITLES = {
            PartNumber: "Part Number",
            Quantity: "Quantity",
            Description: "Description",
            Material: "Material",
            "Matched Childpart": "Select Child Part",
            Type: "Type",
        };

        let spreadsheetData = [];
        let columnsList = [];
        let hot;
        let windowChildParts = []; // expose on window for debugging

        // Fetch query-params (project, part, parentdrgnum) on load and fetch childParts
        window.addEventListener("DOMContentLoaded", async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const project = urlParams.get("project");
            const partNumber = urlParams.get("part");
            const parentDrgNum = urlParams.get("parentdrgnum");
            if (!project || !partNumber || !parentDrgNum) {
                alert("Missing required query params: project/part/parentdrgnum");
                // Do not return; always initialize table even if params are missing
            } else {
                try {
                    const resp = await fetch(
                        "https://ocr-table-extractor.onrender.com/fetch-drawings",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ project, part: partNumber }),
                        }
                    );
                    const data = await resp.json();
                    windowChildParts = data.rows.map((r) =>
                        decodeURIComponent(r.drawingNumber || "")
                    );
                    console.log("✅ Decoded Part Numbers:", windowChildParts);
                } catch (err) {
                    console.error("Error fetching drawing data:", err);
                    windowChildParts = []; // Fallback to empty array
                }
            }
            // Always initialize Handsontable, even if fetch fails or params are missing
            initializeHandsontable();
        });

        // Sequential character matching + best‐match utility
        function sequentialCharacterMatch(part, child) {
            if (!part || !child) return 0;
            const p = part.trim().toUpperCase();
            const c = child.trim().toUpperCase();
            if (p === c) return 1.0;
            if (c.includes(p)) return 0.99;
            let i = 0,
                j = 0,
                matched = 0;
            while (i < p.length && j < c.length) {
                if (p[i] === c[j]) {
                    matched++;
                    i++;
                }
                j++;
            }
            const baseSim = matched / p.length;
            const lengthDiff = Math.abs(p.length - c.length);
            const penalty = lengthDiff > 1 ? (lengthDiff - 1) * 0.1 : 0;
            const sim = Math.max(0, baseSim - penalty);
            if (matched === p.length) return Math.max(0.85, sim);
            return sim;
        }

        function findBestSequentialMatch(partText, drawingNumbers) {
            if (!partText || !drawingNumbers.length || !drawingNumbers.length) {
                return { bestMatch: { target: "", rating: 0 }, allMatches: [] };
            }
            const matches = drawingNumbers.map((d) => ({
                target: d,
                rating: sequentialCharacterMatch(partText, d),
            }));
            matches.sort((a, b) => b.rating - a.rating);
            return { bestMatch: matches[0], allMatches: matches };
        }

        // ─────────────────────────────────────────────────────────────────────
        // Initialize Handsontable with 3 rows + 2 empty rows
        // ─────────────────────────────────────────────────────────────────────
        function initializeHandsontable() {
            // On first load, we want 5 rows of empty objects, each with just the 4 columns:
            // “Select Drawing Number” (key “Matched Childpart”), “Quantity”, “Description”, “Material”.
            spreadsheetData = [];
            for (let i = 0; i < 5; i++) {
                spreadsheetData.push({
                    "PartNumber": { text: "", confidence: 0 }, // Hidden column for matching
                    "Type": "",
                    "Matched Childpart": "",
                    Quantity: { text: "", confidence: 0 },
                    Description: { text: "", confidence: 0 },
                    Material: { text: "", confidence: 0 },
                });
            }

            // Only the 4 columns initially: mapping + 3 OCR
            columnsList = [
                "PartNumber", // Hidden from display but needed for matching
                "Type",
                "Matched Childpart",
                "Quantity",
                "Description",
                "Material",
            ];

            renderSpreadsheet();
        }

        // ─────────────────────────────────────────────────────────────────────
        // renderSpreadsheet (combines OCR columns + mapping columns in one view)
        // ─────────────────────────────────────────────────────────────────────
        function renderSpreadsheet() {
            // Prepare column definitions for Handsontable
            const drawingOptions = windowChildParts.slice(); // from fetched backend
            console.log("🔍 renderSpreadsheet: drawingOptions =", drawingOptions);

            // CRITICAL: Filter out PartNumber from visible columns
            const visibleColumns = columnsList.filter(key => key !== "PartNumber");
            console.log("📋 Visible columns:", visibleColumns);

            // Build column definitions only for visible columns
            const columns = visibleColumns.map((key) => {
                const title = COLUMN_TITLES[key] || key;
                const isMatched = key === "Matched Childpart";
                const isType = key === "Type";
                const isOCRcol = ["Quantity", "Description", "Material"].includes(key);

                return {
                    data: isMatched || isType ? key : `${key}.text`,
                    title,
                    type: isMatched || isType ? "dropdown" : "text",
                    editor: isMatched
                        ? "autocomplete"
                        : isType
                            ? "dropdown"
                            : "text",
                    source: isMatched
                        ? ["", ...drawingOptions]
                        : isType
                            ? ["Child Part", "BO"]
                            : undefined,

                    strict: false,
                    allowInvalid: true,
                    readOnly: false, // all columns remain editable

                    renderer: function (hotInstance, td, row, col, prop, value, cellProps) {
                        if (isMatched || isType) {
                            // dropdown renderer for mapping columns
                            Handsontable.renderers.DropdownRenderer.apply(this, arguments);

                            if (isMatched && value && value.toString().trim() !== "") {
                                // low‐similarity warning on mapping in real time
                                const rowData = hotInstance.getSourceDataAtRow(row);
                                const partCell = rowData["PartNumber"];
                                const partText = partCell?.text || "";

                                if (partText) {
                                    const sim = sequentialCharacterMatch(partText, value.toString());
                                    if (sim < 0.95) {
                                        td.classList.add("low-similarity-cell");
                                    } else {
                                        td.classList.remove("low-similarity-cell");
                                    }
                                }
                            }
                        } else if (isOCRcol) {
                            // OCR columns: color by confidence
                            Handsontable.renderers.TextRenderer.apply(this, arguments);

                            // ✅ CHECK: Was this cell edited by user?
                            const cellMeta = hotInstance.getCellMeta(row, col);
                            const wasEdited = cellMeta.className && cellMeta.className.includes('user-edited-ocr');

                            if (wasEdited) {
                                // ✅ USER EDITED: Keep it white
                                td.style.backgroundColor = "#ffffff";
                            } else {
                                // ✅ OCR DATA: Show confidence colors   
                                const rowData = hotInstance.getSourceDataAtRow(row);
                                const cellObj = rowData[key];  // the { text, confidence } you stored

                                if (cellObj && typeof cellObj === "object" && cellObj.confidence !== undefined) {
                                    const conf = parseFloat(cellObj.confidence || 0);
                                    // Only apply a background if confidence > 0;
                                    // otherwise leave it blank (white).
                                    if (conf > 0) {
                                        if (conf >= 0.95) {
                                            td.style.backgroundColor = "rgba(76, 175, 80, 0.2)";
                                        } else if (conf >= 0.8) {
                                            td.style.backgroundColor = "rgba(255, 152, 0, 0.2)";
                                        } else {
                                            td.style.backgroundColor = "rgba(244, 67, 54, 0.2)";
                                        }
                                    } else {
                                        // No coloring when confidence is zero (empty cell)
                                        td.style.backgroundColor = "";
                                    }
                                }
                            }
                        }
                    },
                };
            });

            // Destroy any existing Handsontable instance
            const container = document.getElementById("hot");
            if (hot) {
                hot.destroy();
            }

            // Re‐create with our new columns + data
            hot = new Handsontable(container, {
                data: spreadsheetData,
                columns,
                colHeaders: visibleColumns.map((k) => COLUMN_TITLES[k]),
                rowHeaders: true,
                minSpareRows: 1,
                // ✅ ADD FORMULAS:
                formulas: { engine: HyperFormula, sheetName: 'Sheet1' },
                // contextMenu: ["col_right","remove_row", "copy", "paste"],
                contextMenu: true,


                dropdownMenu: true,
                filters: true,
                width: '100%',
                heigth: '100%',
                stretchH: 'all',
                autoColumnSize: true, // ← allow text to wrap
                wordWrap: true,
                autoRowSize: true,
                // autoWrapRow: true,
                manualColumnResize: true,
                outsideClickDeselects: true,
                licenseKey: "non-commercial-and-evaluation",

                afterSelectionEnd: function (r, c, r2, c2) {
                    setTimeout(() => {
                        document
                            .querySelectorAll('.wtBorder.current[style*="display: block"]')
                            .forEach((border) => {
                                const style = border.getAttribute("style");
                                if (style.includes("width: 4px")) {
                                    border.setAttribute("style", style.replace("width: 4px", "width: 1px"));
                                }
                                if (style.includes("height: 4px")) {
                                    border.setAttribute("style", style.replace("height: 4px", "height: 1px"));
                                }
                            });
                    }, 0);
                },
            });

            // Re‐attach the “afterChange” hook to mark edited cells & auto‐populate “Type”
            hot.addHook("afterChange", (changes, source) => {
                if (source !== "edit" || !changes) return;
                changes.forEach(([row, prop, oldVal, newVal]) => {
                    if (oldVal === newVal) return;
                    const colIndex = hot.propToCol(prop);

                    hot.setCellMeta(row, colIndex, "className", "edited-cell");

                    // ✅ FIXED: Use correct property names with .text
                    if (["Quantity.text", "Description.text", "Material.text"].includes(prop)) {
                        // Mark as user-edited so renderer knows to keep it white
                        hot.setCellMeta(row, colIndex, "className", "edited-cell user-edited-ocr");
                        console.log(`🔧 User edited OCR cell: Row ${row}, Column ${prop}`);
                    }

                    // If user changed “Matched Childpart”, auto‐populate “Type”
                    //   if (prop === "Matched Childpart") {
                    //     const typeColIdx = hot.propToCol("Type");
                    //     if (typeColIdx !== -1) {
                    //       if (newVal && newVal.toString().trim() !== "") {
                    //         hot.setDataAtCell(row, typeColIdx, "Child Part", "auto-type-population");
                    //       } else {
                    //         hot.setDataAtCell(row, typeColIdx, "BO", "auto-type-population");
                    //       }
                    //     }
                    //   }

                    //New Logic
                    // ✅ REQUIREMENT 2: Validate Select Childpart based on Type
                    if (prop === "Matched Childpart") {
                        const rowData = hot.getSourceDataAtRow(row);
                        const typeValue = rowData["Type"];

                        console.log(`🔍 Select Childpart changed: "${newVal}", Type: "${typeValue}"`);

                        if (typeValue === "Child Part") {
                            // ✅ REQUIREMENT 2: Strict validation for Child Part
                            if (newVal && newVal.toString().trim() !== "") {
                                const isValidChildpart = windowChildParts.includes(newVal.toString());

                                if (!isValidChildpart) {
                                    console.warn(`⚠️ Invalid childpart selection: "${newVal}" - clearing cell`);
                                    // Clear the invalid value
                                    hot.setDataAtCell(row, colIndex, "", "validation-clear");
                                    alert(`"${newVal}" is not a valid child part. Please select from the dropdown list.`);
                                    return; // Don't continue processing
                                } else {
                                    console.log(`✅ Valid childpart selected: "${newVal}"`);
                                }
                            }
                        } else if (typeValue === "BO") {
                            // ✅ REQUIREMENT 3: Allow any value for BO type
                            console.log(`✅ BO type - allowing custom value: "${newVal}"`);
                        }
                    }

                    // Handle Type changes (removed auto-population logic as per Requirement 1)
                    if (prop === "Type") {
                        console.log(`🔄 Type changed to: "${newVal}" for row ${row}`);
                        // Note: Type auto-population removed - now only set by PartNumber OCR
                    }
                    // New Logic Ends here

                });
                hot.render();
            });
            //   // Add this RIGHT AFTER your afterChange hook to test:
            //   console.log("🔧 Testing if afterChange hook works...");
            //   hot.addHook("afterChange", (changes, source) => {
            //     console.log("🚨 BASIC TEST: afterChange fired!", { changes, source });
            //   });
        }

        // ─────────────────────────────────────────────────────────────────────
        // addColumn: used by OCR processing to inject a new column's OCR data
        // ─────────────────────────────────────────────────────────────────────
        function addColumn(newColumnData, label) {
            console.log(`🔧 addColumn called with label: "${label}"`);
            console.log(`📊 Data received:`, newColumnData);

            // Now update spreadsheetData for this column without reordering others
            for (let i = 0; i < newColumnData.length; i++) {
                const text = newColumnData[i]?.text || "";
                const confidence = newColumnData[i]?.confidence || 0;

                // Ensure row exists
                if (!spreadsheetData[i]) {
                    spreadsheetData[i] = {};
                }

                // Store OCR data
                spreadsheetData[i][label] = { text, confidence };
                console.log(`📝 Row ${i}: Set ${label} = "${text}" (confidence: ${confidence})`);

                // CRITICAL: PartNumber matching logic
                if (label === "PartNumber" && text.trim() !== "") {
                    console.log(`🔍 Processing PartNumber matching for row ${i}: "${text}"`);
                    console.log(`🎯 Available drawings:`, windowChildParts);

                    if (windowChildParts && windowChildParts.length > 0) {
                        const best = findBestSequentialMatch(text, windowChildParts);
                        console.log(`🎖️ Best match result:`, best);

                        const matchText = best.bestMatch.rating > 0.85 ? best.bestMatch.target : "";
                        console.log(`✨ Match selected (rating ${best.bestMatch.rating}): "${matchText}"`);

                        // Only auto-populate if not manually set
                        const currentMatch = spreadsheetData[i]["Matched Childpart"];
                        if (!currentMatch || currentMatch === "") {
                            spreadsheetData[i]["Matched Childpart"] = matchText;
                            console.log(`✅ Auto-populated Matched Childpart: "${matchText}"`);
                        } else {
                            console.log(`⏭️ Skipped auto-population - already set to: "${currentMatch}"`);
                        }

                        // Store similarity score for reference
                        spreadsheetData[i]["_similarityScore"] = best.bestMatch.rating;

                        // Auto-populate Type
                        const currentType = spreadsheetData[i]["Type"];
                        if (!currentType || currentType === "") {
                            // const autoType = matchText ? "Child Part" : "BO";
                            const autoType = "Child Part";
                            spreadsheetData[i]["Type"] = autoType;
                            console.log(`✅ Auto-populated Type: "${autoType}"`);
                        }
                    } else {
                        console.warn("⚠️ No drawing numbers available for matching");
                    }
                }
            }

            renderSpreadsheet();
        }

        // ─────────────────────────────────────────────────────────────────────
        // OCR Uploads: Multiple zones, event delegation, state per column
        // ─────────────────────────────────────────────────────────────────────
        const uploads = document.querySelectorAll(".ocr-upload-area");
        const fileStates = {};

        uploads.forEach(area => {
            const input = area.querySelector("input");
            const status = area.querySelector(".file-status");
            const preview = area.querySelector(".ocr-image-preview");
            const column = area.dataset.column;

            input.addEventListener("change", () => {
                const file = input.files[0];
                if (!file) return;

                fileStates[column] = file;
                status.style.display = "inline-block";
                const reader = new FileReader();
                reader.onload = (e) => {
                    preview.innerHTML = `<img src="${e.target.result}" alt="Preview"/>`;
                    area.classList.add("has-file");
                };
                reader.readAsDataURL(file);

                document.getElementById("ocr-process-btn").disabled = Object.keys(fileStates).length === 0;
            });

            
        });

        function clearUpload(buttonEl, event) {
            if (event) event.stopPropagation();

            const area = buttonEl.closest(".ocr-upload-area");
            const input = area.querySelector("input");
            const preview = area.querySelector(".ocr-image-preview");
            const status = area.querySelector(".file-status");
            const column = area.dataset.column;

            if (input) input.value = "";
            if (preview) preview.innerHTML = "";
            if (status) status.style.display = "none";

            area.classList.remove("has-file");
            delete fileStates[column];

            document.getElementById("ocr-process-btn").disabled = Object.keys(fileStates).length === 0;
        }

        // ─────────────────────────────────────────────────────────────────────
        // CRITICAL: OCR Processing with correct column mapping
        // ─────────────────────────────────────────────────────────────────────
        document.getElementById("ocr-process-btn").addEventListener("click", async () => {
            const processBtn = document.getElementById("ocr-process-btn");
            const originalText = processBtn.textContent;
            processBtn.disabled = true;
            processBtn.textContent = "Processing...";

            console.log("🚀 Starting OCR processing...");
            console.log("📁 Files to process:", Object.keys(fileStates));

            // Map upload labels to internal column names
            const columnKeyMap = {
                "Part Number": "PartNumber", // Maps to hidden PartNumber column
                "Quantity": "Quantity",
                "Description": "Description",
                "Material": "Material",
            };

            for (const label in fileStates) {
                const internalColumn = columnKeyMap[label];

                // Add this safety check:
                if (!internalColumn) {
                    console.warn(`⚠️ No mapping found for upload label: ${label}`);
                    continue;
                }

                console.log(`🔄 Processing ${label} → ${internalColumn}`);

                const formData = new FormData();
                formData.append("image", fileStates[label]);
                formData.append("mode", "table");
                formData.append("column", internalColumn);

                try {
                    const resp = await fetch("https://ocr-table-extractor.onrender.com", {
                        method: "POST",
                        body: formData,
                    });
                    const data = await resp.json();

                    console.log(`✅ OCR response for ${label}:`, data);

                    if (data.table && Array.isArray(data.table)) {
                        addColumn(data.table, internalColumn);
                    } else {
                        console.warn(`⚠️ No table data in response for ${label}`);
                    }
                } catch (err) {
                    console.error(`❌ OCR error for ${label}:`, err);
                }
            }

            // Clear preview and fileStates after processing
            uploads.forEach(area => {
                area.querySelector(".file-status").style.display = "none";
                area.querySelector(".ocr-image-preview").innerHTML = "";
                area.querySelector("input").value = "";
                area.classList.remove("has-file");
            });

            Object.keys(fileStates).forEach(k => delete fileStates[k]);
            processBtn.disabled = true;
            processBtn.textContent = originalText; // Restore original text

            // Auto-close OCR panel
            const panel = document.getElementById("ocr-panel");
            panel.classList.remove("open");

            console.log("🏁 OCR processing completed");
        });

        // ─────────────────────────────────────────────────────────────────────
        // OCR Panel Toggle: Extract button opens, Close (X) closes
        // ─────────────────────────────────────────────────────────────────────
        document.getElementById("extract-btn").addEventListener("click", () => {
            const panel = document.getElementById("ocr-panel");
            panel.classList.add("open");
        });
        document.getElementById("ocr-close-btn").addEventListener("click", () => {
            const panel = document.getElementById("ocr-panel");
            panel.classList.remove("open");
        });

        // ─────────────────────────────────────────────────────────────────────
        // Show/Hide help popover
        // ─────────────────────────────────────────────────────────────────────
        document.getElementById("help-icon").addEventListener("click", () => {
            const pop = document.getElementById("help-popover");
            pop.style.display = pop.style.display === "none" ? "block" : "none";
        });
        document.addEventListener("click", (e) => {
            if (!e.target.closest("#help-icon")) {
                document.getElementById("help-popover").style.display = "none";
            }
        });

        // ─────────────────────────────────────────────────────────────────────
        // “Submit” button simply calls your existing sendDataToBackend()
        // ─────────────────────────────────────────────────────────────────────
        document.getElementById("submit-btn").addEventListener("click", () => {
            sendDataToBackend();
        });


        // ─────────────────────────────────────────────────────────────────────
        // validateRequiredFields (unchanged)
        // ─────────────────────────────────────────────────────────────────────
        // UPDATED: Validation function (doesn't check PartNumber since it's hidden)
        function validateRequiredFields() {
            const missingFields = [];
            let hasValidRow = false;

            spreadsheetData.forEach((row, index) => {
                // Check if row has any meaningful data (Type or Quantity)
                const type = row.Type?.trim();
                const qty = row.Quantity?.text?.trim();

                // Skip completely empty rows
                if (!type && !qty) return;

                hasValidRow = true;

                // Validate required fields for non-empty rows
                if (!qty) missingFields.push(`Row ${index + 1}: Quantity`);
                if (!type) missingFields.push(`Row ${index + 1}: Type`);

                // If Type is "Child Part", require Select Drawing Number
                if (type === "Child Part" || type === "BO" && !row["Matched Childpart"]?.trim()) {
                    missingFields.push(`Row ${index + 1}: Child Part/BO (required)`);
                }
            });

            return {
                isValid: hasValidRow && missingFields.length === 0,
                missingFields
            };
        }

        function clearTableToDefault() {
            hot.clear(); // ✅ Built-in method that safely clears all data
            console.log("✅ Table cleared to default state");
        }

        // ─────────────────────────────────────────────────────────────────────
        // Existing sendDataToBackend() function (unchanged from your original)
        // ─────────────────────────────────────────────────────────────────────
        async function sendDataToBackend() {
            const addDataBtn = document.getElementById("submit-btn");
            const originalText = addDataBtn.textContent;

            try {
                // Provide some visual feedback (you can customize as needed)
                addDataBtn.disabled = true;
                addDataBtn.textContent = "Sending...";
                // Validate required fields:
                const validation = validateRequiredFields();
                if (!validation.isValid) {
                    alert(
                        `Missing Required Fields:\n${validation.missingFields.join(
                            ", "
                        )}\nRequired fields:\n- Child Part/BO, Quantity, Type`
                    );
                    addDataBtn.textContent = originalText;
                    return;
                }

                const urlParams = new URLSearchParams(window.location.search);
                const project = urlParams.get("project");
                const parentDrawingNumber = urlParams.get("parentdrgnum");
                const partNumber = urlParams.get("part");
                if (!project || !parentDrawingNumber || !partNumber) {
                    throw new Error("Missing required URL params");
                }

                // Build ChildParts & BO arrays
                const childPartsData = [];
                const boData = [];

                spreadsheetData.forEach((row) => {
                    const frontendPN = row.PartNumber?.text?.trim(); //Hidden data
                    const qty = row.Quantity?.text?.trim();
                    const type = row.Type?.trim();

                    // Skip completely empty rows
                    if (!qty && !type) return;
                    // Validate only the fields users actually submit
                    if (!qty || !type) return;

                    // Additional validation for Child Parts
                    if (type === "Child Part") {
                        childPartsData.push({
                            quantity: qty,
                            description: row.Description?.text?.trim() || "",
                            material: row.Material?.text?.trim() || "",
                            drawingNumber: row["Matched Childpart"] || "",
                        });
                    } else if (type === "BO") {
                        const matched = row["Matched Childpart"]?.trim();
                        boData.push({
                            quantity: qty,
                            description: row.Description?.text?.trim() || "",
                            material: row.Material?.text?.trim() || "",
                            boughtoutPartNumber: row["Matched Childpart"] || "",
                        });
                    }
                });

                // Send to backend
                let successful = 0,
                    total = 0;

                if (childPartsData.length) {
                    total++;
                    const respChild = await fetch(
                        "https://ocr-table-extractor.onrender.com/add-child-parts",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                rows: childPartsData,
                                project,
                                parentDrawingNumber,
                                partNumber,
                            }),
                        }
                    );
                    if (!respChild.ok) {
                        throw new Error(`Failed to add Child Parts: ${await respChild.text()}`);
                    }
                    successful++;
                }
                if (boData.length) {
                    total++;
                    const respBo = await fetch(
                        "https://ocr-table-extractor.onrender.com/add-bo-parts",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                rows: boData,
                                project,
                                parentDrawingNumber,
                                partNumber,
                            }),
                        }
                    );
                    if (!respBo.ok) {
                        throw new Error(`Failed to add BO Parts: ${await respBo.text()}`);
                    }
                    successful++;
                }

                if (successful === total && total > 0) {
                    alert(
                        `Data added successfully!\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}`
                    );
                    clearTableToDefault();
                } else {
                    throw new Error("No data was processed");
                }
            } catch (error) {
                console.error("❌ Error sending data:", error);
                alert(`Error adding data: ${error.message}`);
            } finally {
                addDataBtn.disabled = false;
                addDataBtn.textContent = "Submit";
            }
        }

        lucide.createIcons();

    </script>

</body>

</html>
