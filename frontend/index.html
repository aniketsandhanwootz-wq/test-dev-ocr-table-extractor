<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bulk Add - Column</title>

  <!-- Handsontable CSS and JS from CDN -->
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css">
  <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .container {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    /* Header with logo and title */
    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 9px;
    }

    .logo {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .logo::before {
      content: '‚ú®';
      font-size: 18px;
      filter: brightness(1.2);
    }

    .header h3 {
      margin: 0;
      font-size: 1.2rem;
      color: #333;
      font-weight: 500;
    }

    /* Instructions section */
    .instructions {
      background: #f8f9ff;
      border: 1px solid #e1e5f2;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 20px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #4a5568;
    }

    .instructions strong {
      color: #2d3748;
    }

    .sample-link {
      color: #667eea;
      text-decoration: none;
      font-weight: 500;
    }

    .sample-link:hover {
      text-decoration: underline;
    }
    
    .secondary-button {
      background-color: #ccc;
      color: #333;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    .secondary-button:hover {
      opacity: 0.8;
    }

    /* Hidden mode select - keeps default functionality */
    #mode-select {
      display: none;
    }

    /* 2x2 Grid Layout - Larger areas to fill space */
    .upload-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
      max-width: 320px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Process button and preview layout */
    .process-preview-container {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 15px;
      align-items: start;
      margin-bottom: 20px;
    }

    .process-section {
      display: flex;
      justify-content: flex-end;
    }

    .upload-area {
      position: relative;
      border: 2px dashed #ccc;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      background: #fafafa;
      transition: all 0.3s ease;
      cursor: pointer;
      min-height: 55px;
      max-height: 65px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
    }

    /* Subtle upload icon styling */
    .upload-icon {
      color: #9ca3af;
      margin-bottom: 2px;
      transition: all 0.3s ease;
    }
    
    .upload-icon i {
      width: 12px;
      height: 12px;
    }
    
    .upload-area:hover .upload-icon {
      color: #6b7280;
    }
    
/*     .upload-area.has-file .upload-icon {
      color: #10b981;
    } */
    

    .upload-clear-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      background: rgba(108, 117, 125, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 8px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      line-height: 1;
      opacity: 0.7;
      transition: all 0.2s ease;
    }

    .upload-clear-btn:hover {
      background: rgba(220, 53, 69, 0.9);
      opacity: 1;
      transform: scale(1.1);
    }

    .upload-area.has-file .upload-clear-btn {
      display: flex;
    }

    .upload-area:hover {
      border-color: #007bff;
      background: #f0f8ff;
      transform: scale(1.05);
    }

    .upload-area.dragover {
      border-color: #0056b3;
      background: #e6f3ff;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.4);
      transform: scale(1.1);
    }

    .upload-area.nearby {
      border-color: #007bff;
      background: #f0f8ff;
      transform: scale(1.05);
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.2);
    }

    .upload-area.has-file {
      border-color: #28a745;
      border-style: solid;
      background: #f8fff9;
    }

    .upload-label {
      font-weight: normal;
      margin-bottom: 3px;
      font-size: 0.8rem;
      line-height: 1.1;
    }

    .required {
      color: #dc3545;
      margin-left: 2px;
    }

    .upload-area input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      z-index: 2;
    }

    .file-status {
      font-size: 0.7rem;
      color: #28a745;
      font-weight: bold;
      margin-top: 3px;
      line-height: 1;
    }

    /* highlight user-edited cells */
    .edited-cell {
      box-shadow: inset 0 0 0 2px orange !important;
    }
    
    #process-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 0;
      transition: background-color 0.3s ease;
    }
    
    #process-btn:hover:not(:disabled) {
      background: #0056b3;
    }

    #process-btn:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Preview container - hidden by default */
    #image-preview {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      position: relative;
      display: none; /* Hidden by default */
      max-width: 200px; /* Reduced size */
    }

    #image-preview.has-image {
      display: block; /* Only show when has image */
    }
    
    #image-preview img {
      max-width: 100%; /* Responsive within smaller container */
      height: auto;
      display: block;
      margin-top: 10px;
    }

    .preview-remove-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 20px;
      height: 20px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .preview-remove-btn:hover {
      background: #c82333;
    }

    /* Responsive design */
    @media (max-width: 400px) {
      .upload-grid {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(4, 1fr);
      }
    }

    /* More prominent but subtle dropdown styling */
/*     .handsontable .htSelectEditor {
      background: #ffffff !important;
      border: 1px solid #2196f3 !important;
      border-radius: 3px !important;
      box-shadow: 0 2px 4px rgba(33, 150, 243, 0.15) !important;
      z-index: 1000 !important;
    }

    .handsontable .htSelectEditor option {
      padding: 5px 10px !important;
      background: white !important;
    }

    .handsontable .htSelectEditor option:hover {
      background: #e3f2fd !important;
    } */

    /* Style the autocomplete dropdown container */
    .handsontableInputHolder {
/*       border: 1px solid #2196f3 !important; */
      border-radius: 3px !important;
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3) !important;
      background: white !important;
      margin-top: 2px !important;
      max-width: 300px !important;
    }
    
    /* Style the autocomplete dropdown table */
    .handsontableInputHolder .htCore {
      border: none !important;
    }
    
    .handsontableInputHolder td {
      border-color: #f0f0f0 !important;
      padding: 2px 6px !important;
      line-height: 1.1 !important;
    }
    
    .handsontableInputHolder tr:hover td {
      background-color: #e3f2fd !important;
    }
    
    .handsontableInputHolder .current td {
      background-color: #2196f3 !important;
      color: white !important;
    }

    /* Low similarity warning - just icon */
    .low-similarity-cell {
      position: relative;
    }

    .low-similarity-cell::after {
      content: '‚ö†Ô∏è';
      position: absolute;
      top: 1px;
      right: 1px;
      font-size: 11px;
      z-index: 10;
      pointer-events: none;
    }
  
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo"></div>
      <h3>Upload Columns</h3>
    </div>

    <div class="instructions">
        üî¢ Include 10 rows | üîç Make zoom and sharp | üö´ No headers 
    </div>

    <!-- Hidden but functional mode select -->
    <select id="mode-select">
      <option value="table" selected>Column-by-Column Table Extract</option>
      <option value="quick">Quick Text Copy (Paragraph)</option>
    </select>
    
    <div class="upload-grid">
      <!-- Part Number -->
      <div class="upload-area" id="area-partNumber" data-column="partNumber">
        <button class="upload-clear-btn" onclick="clearUpload('partNumber', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>
        <div class="upload-label">Part Number <span class="required">*</span></div>
        <input type="file" id="upload-partnumber" accept="image/*" />
        <div class="file-status" id="status-partNumber" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Quantity -->
      <div class="upload-area" id="area-quantity" data-column="quantity">
        <button class="upload-clear-btn" onclick="clearUpload('quantity', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>
        <div class="upload-label">Quantity <span class="required">*</span></div>
        <input type="file" id="upload-quantity" accept="image/*" />
        <div class="file-status" id="status-quantity" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Description -->
      <div class="upload-area" id="area-description" data-column="description">
        <button class="upload-clear-btn" onclick="clearUpload('description', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>        
        <div class="upload-label">Description</div>
        <input type="file" id="upload-description" accept="image/*" />
        <div class="file-status" id="status-description" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Material -->
      <div class="upload-area" id="area-material" data-column="material">
        <button class="upload-clear-btn" onclick="clearUpload('material', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>        
        <div class="upload-label">Material</div>
        <input type="file" id="upload-material" accept="image/*" />
        <div class="file-status" id="status-material" style="display: none;">‚úì Uploaded</div>
      </div>
    </div>

    <div style="text-align: right; margin: 10px 0;">
      <button id="process-btn">Process Image</button>
    </div>

    <div id="image-preview">
      <button class="preview-remove-btn" onclick="clearPreview()">√ó</button>
    </div>

    <div id="result-container"></div>
    <button id="download-btn" class="secondary-button" style="display: none;">Download as CSV</button>
    <div id="hot" style="width: 100%; height: 400px; display: none;"></div>
    
  </div>

  <script>

    // :-----------------------------------------:
    //  Column key ‚Üí display title mapping
    // :-----------------------------------------:
    const COLUMN_TITLES = {
      PartNumber:            "Part Number",
      Quantity:              "Quantity",
      Description:           "Description",
      Material:              "Material",
      "Matched Childpart":   "Select Drawing Number",
      Type:                  "Type"
    };
    
    let spreadsheetData = [];
    let columnsList = [];
    let columnCount = 0;
    let hot;

    const uploads = {
      partNumber: document.getElementById("upload-partnumber"),
      description: document.getElementById("upload-description"),
      quantity: document.getElementById("upload-quantity"),
      material: document.getElementById("upload-material")
    };

    const columnOrder = [
      { id: "partNumber", label: "PartNumber" },
      { id: "description", label: "Description" },
      { id: "quantity", label: "Quantity" },
      { id: "material", label: "Material" }
    ];

    // Similarity Matching functions
    // ============================================
    // SEQUENTIAL CHARACTER MATCHING (CORRECTED)
    // ============================================
    
    function sequentialCharacterMatch(partNumber, childPart) {
      if (!partNumber || !childPart) return 0;
      
      // Normalize inputs
      const part = partNumber.trim().toUpperCase();
      const child = childPart.trim().toUpperCase();
      
      // Exact match
      if (part === child) return 1.0;
      
      // Check if PartNumber exists as a substring anywhere in ChildPart
      if (child.includes(part)) {
        return 0.99; // Perfect substring match - PartNumber found anywhere in ChildPart
      }
      
      // Sequential character matching - find all characters of PartNumber in order
      let partIndex = 0;
      let childIndex = 0;
      let matchedChars = 0;
      
      // Go through each character in childPart
      while (childIndex < child.length && partIndex < part.length) {
        if (part[partIndex] === child[childIndex]) {
          matchedChars++;
          partIndex++;
        }
        childIndex++;
      }
      
      // Calculate similarity based on how much of partNumber was found
      const similarity = matchedChars / part.length;
      
      // Bonus if we found ALL characters of partNumber in order (but not as exact substring)
      if (matchedChars === part.length) {
        return 0.95; // All characters found in order
      }
      
      return similarity;
    }
    
    function findBestSequentialMatch(partNumber, drawingNumbers) {
      if (!partNumber || !drawingNumbers || drawingNumbers.length === 0) {
        return {
          bestMatch: { target: '', rating: 0 },
          allMatches: []
        };
      }
      
      const matches = drawingNumbers.map(drawing => ({
        target: drawing,
        rating: sequentialCharacterMatch(partNumber, drawing)
      }));
      
      // Sort by similarity (highest first)
      matches.sort((a, b) => b.rating - a.rating);
      
      return {
        bestMatch: matches[0],
        allMatches: matches
      };
    }

    
    const API_URL = 'https://ocr-table-extractor.onrender.com';

    window.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const project = urlParams.get("project");
      const partNumber = urlParams.get("part");
      const parentDrgNum = urlParams.get("parentdrgnum");

      if (!project || !partNumber || !parentDrgNum) {
        alert("Missing query params: project or part or parent drawing number");
        return;
      }

      try {
        const response = await fetch("https://ocr-table-extractor.onrender.com/fetch-drawings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ project, part: partNumber })
        });
        const data = await response.json();
        console.log("‚úÖ Filtered drawing data from Glide via backend:", data.rows);
        window.childParts = data.rows;
      } catch (err) {
        console.error("‚ùå Error fetching drawing data:", err);
      }
    });

    function textRenderer(instance, td, row, col, prop, value, cellProperties) {
      Handsontable.renderers.TextRenderer.apply(this, arguments);
      const rowData = instance.getSourceDataAtRow(row);
      if (rowData && rowData[prop] && typeof rowData[prop] === 'object') {
        const cellData = rowData[prop];
        td.innerText = cellData.text;
        const conf = parseFloat(cellData.confidence);
        if (conf >= 0.9) td.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
        else if (conf >= 0.7) td.style.backgroundColor = 'rgba(255, 152, 0, 0.2)';
        else td.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
      } else {
        td.innerText = value;
      }
    }

    function renderSpreadsheet() {
      // ensure the new column is in the right spot
      if (columnsList.includes("Matched Childpart") && !columnsList.includes("Type")) {
        const idx = columnsList.indexOf("Matched Childpart");
        columnsList.splice(idx + 1, 0, "Type");
      }
      
      const columns = [];
      const colHeaders = [];
    
      columnsList.forEach(key => {
        const title = COLUMN_TITLES[key] || key;
        const isMatched = key === 'Matched Childpart';
        const isType    = key === "Type";
        const drawingOptions = Array.isArray(window.childParts)
          ? window.childParts.map(p => p.drawingNumber || '')
          : [];
    
        columns.push({
          // 1) editor & data binding
          data:       (isMatched || isType) ? key : `${key}.text`,
          title,
          type:       (isMatched || isType) ? 'dropdown' : 'text',
          // editor:     (isMatched || isType) ? 'dropdown' : 'text',
          editor: isMatched ? 'autocomplete' : isType ? 'dropdown' : 'text',
          source:     isMatched ? ['', ...drawingOptions] : isType ? ['', 'Child Part','BO'] : undefined, // Add empty option first
          strict:     false, // Allow free text for both dropdown columns
          allowInvalid: true, // Allow invalid/empty values for both columns
          // filter:     (isMatched || isType) ? 'dropdown' : false, // Enable dropdown filtering
          // trimDropdown: false, // Show all options initially


          
              // 2) custom renderer for OCR columns
          renderer: (isMatched || isType)
            ? function(hotInst, td, row, col, prop, value, cellProps) {
                // Default dropdown renderer
                Handsontable.renderers.DropdownRenderer.apply(this, arguments);
                
                // Add low similarity warning for Matched Childpart
                if (isMatched && value && value.trim() !== '') {
                  const rowData = hotInst.getSourceDataAtRow(row);
                  const partNumberData = rowData['PartNumber'];
                  
                  if (partNumberData && partNumberData.text && window.childParts?.length) {
                    const drawingNumbers = window.childParts.map(p => p.drawingNumber || '');
                    const result = findBestSequentialMatch(partNumberData.text, drawingNumbers);
                    
                    // Check if current value matches the best match and get its similarity
                    let similarity = 0;
                    if (result.bestMatch.target === value) {
                      similarity = result.bestMatch.rating;
                    } else {
                      // If it's not the best match, find similarity for current value
                      const currentMatch = sequentialCharacterMatch(partNumberData.text, value);
                      similarity = currentMatch;
                    }
                    
                    console.log(`Similarity for "${value}": ${similarity}`); // Debug log
                    // Add this right before the similarity check:
                    console.log(`Rendering ${value}, similarity: ${similarity}, classes: ${td.className}`);
                    
                    if (similarity > 0 && similarity < 0.95) {
                      td.classList.add('low-similarity-cell');
                    } else {
                      td.classList.remove('low-similarity-cell');
                    }
                  }
                } else {
                  td.classList.remove('low-similarity-cell');
                }
              }
            : function(hotInst, td, row, col, prop, value, cellProps) {
                // first draw the text
                Handsontable.renderers.TextRenderer.apply(this, arguments);
    
                // then pull the original object back out
                const rowData = hotInst.getSourceDataAtRow(row);
                const cellObj = rowData[key];  // the {text, confidence} you stored
    
                if (cellObj && typeof cellObj === 'object') {
                  const conf = parseFloat(cellObj.confidence);
                  if (conf >= 0.9) {
                    td.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
                  } else if (conf >= 0.7) {
                    td.style.backgroundColor = 'rgba(255, 152, 0, 0.2)';
                  } else {
                    td.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
                  }
                }
              }
        });
    
        colHeaders.push(key);
      });
    
      const container = document.getElementById('hot');
      container.style.display = 'block';
    
      if (hot) hot.destroy();
      hot = new Handsontable(container, {
        data: spreadsheetData,
        columns,
        colHeaders,
        rowHeaders: true,
        minSpareRows: 1,
        contextMenu: ['remove_row','copy','paste'],
        licenseKey: 'non-commercial-and-evaluation',
        dropdownMenu: true, // Enable dropdown menu
        filters: true, // Enable filtering
        // Add autocomplete settings for better dropdown filtering
        autoColumnSize: true,        
        // Prevent auto-selection in dropdowns
        afterSelectionEnd: function(row, column, row2, column2) {
          const prop = hot.colToProp(column);
          if (prop === 'Matched Childpart' || prop === 'Type') {
            // Don't auto-select first item when opening dropdown
            const editor = hot.getActiveEditor();
            if (editor && editor.isOpened && editor.isOpened()) {
              editor.focus();
            }
          }
        },
      });
      
      // Enhanced change handler
      hot.addHook('afterChange', (changes, source) => {
        // only care about real user edits
        if (source !== 'edit' || !changes) return;
      
        changes.forEach(([row, prop, oldValue, newValue]) => {
          // skip if value didn't actually change
          if (oldValue === newValue) return;
      
          const col = hot.propToCol(prop);
          // mark this cell as edited
          hot.setCellMeta(row, col, 'className', 'edited-cell');
          
          // Handle Type column auto-population when Matched Childpart changes
          if (prop === 'Matched Childpart') {
            const typeCol = hot.propToCol('Type');
            if (typeCol !== -1) {
              // Only auto-populate Type if user didn't explicitly set it to empty
              if (newValue && newValue.trim() !== '') {
                hot.setDataAtCell(row, typeCol, 'Child Part', 'auto-type-population');
              } else if (newValue === '' || newValue === null) {
                // Don't auto-populate when user clears the field
                hot.setDataAtCell(row, typeCol, 'BO', 'auto-type-population');
              }
            }
          }
        });
      
        // re-render so every flagged cell gets the CSS
        hot.render();
      });
    }

    function addColumn(newColumnData, label) {
      columnsList.push(label);
      if (label === "PartNumber" && !columnsList.includes("Matched Childpart")) {
        columnsList.push("Matched Childpart");
        columnsList.push("Type");
      }

      for (let i = 0; i < newColumnData.length; i++) {
        const text = newColumnData[i].text || "";
        const confidence = newColumnData[i].confidence || 0;
        if (!spreadsheetData[i]) spreadsheetData[i] = {};
        spreadsheetData[i][label] = { text, confidence };

        if (label === "PartNumber" && window.childParts?.length) {
          const drawingNumbers = window.childParts.map(p => p.drawingNumber || "");
          const result = findBestSequentialMatch(text, drawingNumbers);
          const matchText = result.bestMatch.rating > 0.85 ? result.bestMatch.target : "";
          
          // Store both the match and similarity score for later use
          spreadsheetData[i]["Matched Childpart"] = matchText;
          spreadsheetData[i]["_similarityScore"] = result.bestMatch.rating; // Store for reference
          
          // Type cell: auto‚Äêpopulate
          // only set Type if there's actually a PartNumber
          if (text) {
            spreadsheetData[i]["Type"] = matchText ? "Child Part" : "BO";
          }
        }

        for (let i = newColumnData.length; i < spreadsheetData.length; i++) {
          // only if there's really a PartNumber in that row
          const part = spreadsheetData[i]["PartNumber"]?.text;
          if (part) {
            const hasMatch = spreadsheetData[i]["Matched Childpart"]?.text;
            spreadsheetData[i]["Type"] = hasMatch ? "Child Part" : "BO";
          }
       }
      }

      renderSpreadsheet();
    }

    document.getElementById("process-btn").onclick = async function () {
      spreadsheetData = [];
      columnsList = [];
      columnCount = 0;

      for (const col of columnOrder) {
        const fileInput = uploads[col.id];
        const file = fileInput.files[0];
        
        // Check required fields
        if (!file && (col.id === "partNumber" || col.id === "quantity")) {
          alert(`Please upload an image for ${col.label}`);
          return;
        }
        
        // Skip if no file for optional fields
        if (!file) {
          console.log(`‚è≠Ô∏è Skipping ${col.id} - no file uploaded`);
          continue;
        }

        const formData = new FormData();
        formData.append("image", file);
        formData.append("mode", "table");

        // Log & tell the backend which column we're OCR'ing
        console.log(`üöÄ OCR request for column: ${col.id}`);
        formData.append("column", col.id);

        try {
          const response = await fetch(API_URL, {
            method: "POST",
            body: formData
          });

          const data = await response.json();
          console.log(`‚úÖ OCR response for ${col.id}:`, data);
          
          if (data.table && Array.isArray(data.table)) {
            addColumn(data.table, col.label);
          } else {
            console.warn(`‚ö†Ô∏è No table data returned for ${col.id}`);
          }
        } catch (error) {
          console.error(`‚ùå Error processing ${col.id}:`, error);
          // Don't stop processing other columns if one fails
          console.log(`Continuing with other columns...`);
        }
      }
    };

    const previewContainer = document.getElementById("image-preview");

    // Drag and drop functionality
    let dragCounter = 0;

    // Get nearest upload area based on mouse position
    function getNearbyUploadArea(x, y, threshold = 120) {
      const areas = document.querySelectorAll('.upload-area');
      let closestArea = null;
      let minDistance = threshold;
      
      areas.forEach(area => {
        const rect = area.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Calculate distance to center
        const distance = Math.sqrt(
          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
        );
        
        // Also check if cursor is within extended bounds (for corners/edges)
        const extendedRect = {
          left: rect.left - 30,
          right: rect.right + 30,
          top: rect.top - 30,
          bottom: rect.bottom + 30
        };
        
        const withinExtendedBounds = x >= extendedRect.left && x <= extendedRect.right &&
                                   y >= extendedRect.top && y <= extendedRect.bottom;
        
        if ((distance < minDistance || withinExtendedBounds) && distance < 150) {
          minDistance = distance;
          closestArea = area;
        }
      });
      
      return closestArea;
    }

    // Clear all nearby highlights
    function clearNearbyHighlights() {
      document.querySelectorAll('.upload-area').forEach(area => {
        area.classList.remove('nearby');
      });
    }

    // Global drag events for vicinity detection
    document.addEventListener('dragenter', function(e) {
      e.preventDefault();
      dragCounter++;
    });

    document.addEventListener('dragover', function(e) {
      e.preventDefault();
      
      // Check if we're dragging files
      const hasFiles = e.dataTransfer && (
        e.dataTransfer.types.includes('Files') || 
        e.dataTransfer.types.includes('application/x-moz-file')
      );
      
      if (hasFiles) {
        // Set the drop effect
        e.dataTransfer.dropEffect = 'copy';
        
        const nearbyArea = getNearbyUploadArea(e.clientX, e.clientY);
        
        clearNearbyHighlights();
        if (nearbyArea && !nearbyArea.classList.contains('dragover')) {
          nearbyArea.classList.add('nearby');
        }
      }
    });

    document.addEventListener('dragleave', function(e) {
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        clearNearbyHighlights();
      }
    });

    document.addEventListener('drop', function(e) {
      dragCounter = 0;
      clearNearbyHighlights();
    });

    // Setup individual upload areas
    document.querySelectorAll('.upload-area').forEach(area => {
      const col = area.dataset.column;
      const input = uploads[col];

      // Click to upload
      area.addEventListener('click', function(e) {
        input.click();
      });

      // File input change
      input.addEventListener('change', function() {
        if (input.files[0]) {
          area.classList.add('has-file');
          document.getElementById(`status-${col}`).style.display = 'block';
          
          // Store which column was last uploaded for the clear function
          previewContainer.dataset.lastColumn = col;
          
          // Update preview and button state
          const columnName = area.querySelector('.upload-label').textContent.trim();
          showImagePreview(input.files[0], columnName);
          updateProcessButton();
        } else {
          // Reset to initial state when no file is chosen
          area.classList.remove('has-file');
          document.getElementById(`status-${col}`).style.display = 'none';
          updateProcessButton();
        }
      });

      // Drag events for individual areas
      area.addEventListener('dragenter', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Check if we have files being dragged
        if (e.dataTransfer.types.includes('Files')) {
          area.classList.add('dragover');
          clearNearbyHighlights();
        }
      });

      area.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Ensure we're handling files
        if (e.dataTransfer.types.includes('Files')) {
          e.dataTransfer.dropEffect = 'copy';
        }
      });

      area.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Only remove dragover if we're actually leaving the area
        const rect = area.getBoundingClientRect();
        const x = e.clientX;
        const y = e.clientY;
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
          area.classList.remove('dragover');
        }
      });

      area.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        area.classList.remove('dragover');
        clearNearbyHighlights();
        
        // Ensure we have files and handle them properly
        if (e.dataTransfer.files.length > 0) {
          const dt = new DataTransfer();
          for (let i = 0; i < e.dataTransfer.files.length; i++) {
            dt.items.add(e.dataTransfer.files[i]);
          }
          input.files = dt.files;
          
          // Trigger change event manually to ensure all handlers run
          const changeEvent = new Event('change', { bubbles: true });
          input.dispatchEvent(changeEvent);
        }
      });
    });

    // Enable/disable process button based on required files
    function updateProcessButton() {
      const hasRequired = uploads.partNumber.files.length > 0 && uploads.quantity.files.length > 0;
      document.getElementById("process-btn").disabled = !hasRequired;
    }

    // Initialize button state
    updateProcessButton();

    // Preview function with remove button
    function showImagePreview(file, label) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.src = event.target.result;
        img.style.maxWidth = "300px";
        img.alt = label;
    
        // Clear previous preview and insert new one
        previewContainer.innerHTML = `<button class="preview-remove-btn" onclick="clearPreview()">√ó</button><strong>${label}</strong><br>`;
        previewContainer.appendChild(img);
        previewContainer.classList.add('has-image');
      };
      reader.readAsDataURL(file);
    }

    // Function to clear preview and reset corresponding upload
    function clearPreview() {
      // Get the last column BEFORE clearing it
      const lastUploadedColumn = previewContainer.dataset.lastColumn;
      
      previewContainer.innerHTML = '<button class="preview-remove-btn" onclick="clearPreview()">√ó</button>';
      previewContainer.classList.remove('has-image');
      previewContainer.dataset.lastColumn = ''; // <-- This is needed!
      
      // Find and clear the last uploaded file
      if (lastUploadedColumn) {
        const input = uploads[lastUploadedColumn];
        if (input) {
          input.value = '';
          document.getElementById(`area-${lastUploadedColumn}`).classList.remove('has-file');
          document.getElementById(`status-${lastUploadedColumn}`).style.display = 'none';
          updateProcessButton();
        }
      }
    }

    // Function to clear specific upload area
    function clearUpload(columnId, event) {
      if (event) {
        event.stopPropagation(); // Prevent bubbling to parent upload area
      }

      const input = uploads[columnId];
      const area = document.getElementById(`area-${columnId}`);
      const status = document.getElementById(`status-${columnId}`);
      
      if (input) {
        input.value = '';
        area.classList.remove('has-file');
        status.style.display = 'none';
        updateProcessButton();
        
        // Clear preview if this was the last uploaded file
        if (previewContainer.dataset.lastColumn === columnId) {
          previewContainer.innerHTML = '<button class="preview-remove-btn" onclick="clearPreview()">√ó</button>';
          previewContainer.classList.remove('has-image');
          previewContainer.dataset.lastColumn = '';
        }
      }
    }

    // Make clearPreview and clearUpload globally accessible
    window.clearPreview = clearPreview;
    window.clearUpload = clearUpload;
    
    // Attach onchange handlers (keeping original preview functionality)
    uploads.partNumber.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'partNumber';
        showImagePreview(e.target.files[0], "PartNumber Preview");
        updateProcessButton();
      }
    });
    uploads.quantity.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'quantity';
        showImagePreview(e.target.files[0], "Quantity Preview");
        updateProcessButton();
      }
    });
    uploads.description.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'description';
        showImagePreview(e.target.files[0], "Description Preview");
      }
    });
    uploads.material.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'material';
        showImagePreview(e.target.files[0], "Material Preview");
      }
    });

    // Initialize Lucide icons
    lucide.createIcons();
    
  </script>
</body>
</html>
