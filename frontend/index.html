<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OCR Table Extractor</title>
  <link rel="stylesheet" href="style.css">

  <!-- Handsontable CSS and JS from CDN -->
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css">
  <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>OCR Table Extractor</h1>

    <!-- Mode selection -->
    <select id="mode-select">
      <option value="quick">Quick Text Copy (Paragraph)</option>
      <option value="table">Column-by-Column Table Extract</option>
    </select>

    <!-- Image uploader and preview -->
    <input type="file" id="image-upload" accept="image/png, image/jpeg" />
    <div id="image-preview"></div>
    <button id="process-btn">Process Image</button>

    <!-- Results container for non-spreadsheet results -->
    <div id="result-container"></div>

    <!-- Download button placed above the spreadsheet -->
    <button id="download-btn" style="display: none;">Download Result</button>
    
    <!-- Container for Handsontable spreadsheet (hidden by default) -->
    <div id="hot" style="width: 100%; height: 400px; display: none;"></div>
  </div>

  <script>
    // Global variables for spreadsheet data and state.
    let spreadsheetData = []; // Array of row objects. Each key: "Column 1", "Column 2", etc.
    let columnCount = 0;      // How many columns have been added.
    let hot;                  // Handsontable instance

    // Preview the uploaded image.
    document.getElementById('image-upload').onchange = function(e) {
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.src = event.target.result;
        img.style.maxWidth = '300px';
        const preview = document.getElementById('image-preview');
        preview.innerHTML = '';
        preview.appendChild(img);
      };
      reader.readAsDataURL(e.target.files[0]);
    };

    // Custom renderer for the text cell.
    // It expects the cell value to be an object: { text: string, conf: number }
    // It sets the background color based on the confidence thresholds:
    // 0.9-1.0 => green, 0.7-0.9 => orange, < 0.7 => red.
    function textRenderer(instance, td, row, col, prop, value, cellProperties) {
      Handsontable.renderers.TextRenderer.apply(this, arguments);
      const rowData = instance.getSourceDataAtRow(row);
      if (rowData && rowData[prop] && typeof rowData[prop] === 'object') {
        const cellData = rowData[prop];
        td.innerText = cellData.text; // Display only the text
        if (cellData.conf >= 0.9) {
          td.style.backgroundColor = 'rgba(76, 175, 80, 0.2)'; // Green
        } else if (cellData.conf >= 0.7) {
          td.style.backgroundColor = 'rgba(255, 152, 0, 0.2)'; // Orange
        } else {
          td.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';  // Red
        }
      } else {
        td.innerText = value;
      }
    }

    // Function to (re)render the Handsontable spreadsheet.
    function renderSpreadsheet() {
      let columns = [];
      let colHeaders = [];
      for (let i = 1; i <= columnCount; i++) {
        const key = 'Column ' + i;
        columns.push({ data: key, title: key, renderer: textRenderer });
        colHeaders.push(key);
      }
      
      const container = document.getElementById('hot');
      container.style.display = 'block';
      
      if (hot) {
        hot.destroy();
      }
      
      hot = new Handsontable(container, {
        data: spreadsheetData,
        columns: columns,
        colHeaders: colHeaders,
        rowHeaders: true,
        minSpareRows: 1, // Enables user to add rows
        contextMenu: true,
        licenseKey: 'non-commercial-and-evaluation'
      });
    }

    // Function to add a new column from OCR data.
    // newColumnData is an array of objects: each { text: string, conf: number }.
    function addColumn(newColumnData) {
      columnCount++;
      const colKey = 'Column ' + columnCount;
      
      // Merge new column into spreadsheetData.
      for (let i = 0; i < newColumnData.length; i++) {
        if (i < spreadsheetData.length) {
          spreadsheetData[i][colKey] = newColumnData[i];
        } else {
          let newRow = {};
          for (let j = 1; j < columnCount; j++) {
            newRow['Column ' + j] = { text: '', conf: 0 };
          }
          newRow[colKey] = newColumnData[i];
          spreadsheetData.push(newRow);
        }
      }
      for (let i = newColumnData.length; i < spreadsheetData.length; i++) {
        spreadsheetData[i][colKey] = { text: '', conf: 0 };
      }
      
      renderSpreadsheet();
    }

    // Process button handler.
    document.getElementById('process-btn').onclick = async function () {
      const imageInput = document.getElementById('image-upload');
      const mode = document.getElementById('mode-select').value;
      const resultContainer = document.getElementById('result-container');

      if (!imageInput.files[0]) {
        alert("Please upload an image first!");
        return;
      }

      const fileSizeMB = imageInput.files[0].size / (1024 * 1024);
      if (fileSizeMB > 2) {
        alert(`Image size (${fileSizeMB.toFixed(2)}MB) is too large. Please use an image under 2MB.`);
        return;
      }

      resultContainer.innerHTML = '<div class="loading">Processing... This may take up to 30 seconds.</div>';

      const formData = new FormData();
      formData.append('image', imageInput.files[0]);
      formData.append('mode', mode);

      try {
        // Replace with your actual backend URL.
        const API_URL = 'https://ocr-table-extractor.onrender.com';
        
        // Optional: Test API.
        const testResponse = await fetch(`${API_URL}/test`);
        if (!testResponse.ok) {
          throw new Error(`API test failed with status: ${testResponse.status}`);
        }
        console.log("API test successful");

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 60000);
        const response = await fetch(API_URL, {
          method: 'POST',
          body: formData,
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Server error (${response.status}): ${errorText}`);
        }
        
        const data = await response.json();

        if (mode === "table" && data.table) {
          addColumn(data.table);
          resultContainer.innerHTML = '<h3>Spreadsheet Updated.</h3>';
        } else if (mode === "quick" && data.extracted_text) {
          resultContainer.innerHTML = `
            <h3>Extracted Text:</h3>
            <div class="extracted-text">${data.extracted_text.replace(/\n/g, '<br>')}</div>
          `;
        } else {
          resultContainer.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
        }
        
        document.getElementById('download-btn').style.display = 'block';
      } catch (error) {
        if (error.name === 'AbortError') {
          resultContainer.innerHTML = '<p class="error">Request timed out. Try a smaller image or try again later.</p>';
        } else {
          resultContainer.innerHTML = `<p class="error">Error: ${error.message}</p>`;
        }
        console.error('Error details:', error);
      }
    };
  </script>
</body>
</html>
