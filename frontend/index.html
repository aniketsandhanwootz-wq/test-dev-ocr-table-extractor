<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hybrid OCR & Manual Entry Tool</title>

  <!-- Handsontable CSS and JS from CDN -->
  <link
    rel="stylesheet"
    type="text/css"
    href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css"
  />
  <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    /* --------------------- Global & Container Styles --------------------- */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      background: #0d0d0d;
      color: #ffffff;
      overflow: hidden; /* Prevent body scroll */
    }
    #hybrid-tool-container {
      width: 1277px;
      max-height: 758px;
      background-color: #0d0d0d;
      padding: 0 24px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    #main-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* --------------------- Top Row Controls --------------------- */
    #top-row-controls {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-top: 16px;
      margin-bottom: 16px;
    }
    #tool-heading {
      font-size: 16px;
      font-weight: 500;
      color: #ffffff;
    }
    #top-row-right {
      display: flex;
      gap: 12px;
    }

    /* --------------------- Table Action Buttons --------------------- */
    #table-action-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-bottom: 8px;
    }

    #table-action-buttons button {
      border: none;
      border-radius: 4px;
      padding: 6px 16px;
      font-size: 14px;
      cursor: pointer;
    }

    #extract-btn {
      background-color: #333;
      color: #fff;
    }

    #submit-btn {
      background-color: #fbbf24;
      color: #fff;
      font-weight: 700;
    }

    /* --------------------- Table & OCR Wrapper --------------------- */
    #table-and-ocr-wrapper {
      display: flex;
      flex: 1;
      overflow: visible;
    }

    /* --------------------- Handsontable Area --------------------- */
    #handsontable-container {
      flex: 1 1 auto;
      margin-right: 16px;
      overflow: auto;
    }
    /* Override cell borders to #444 */
    #handsontable-container .wtBorder {
      border-color: #444 !important;
    }
    /* Wrap long text in cells */
    .handsontable td .htCore {
      white-space: normal !important;
    }
    /* Instructions bar above the table */
    .instructions {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #ccc;
    }
    .instructions strong {
      color: #fff;
    }
    .help-icon {
      float: right;
      cursor: pointer;
      opacity: 0.7;
      position: relative;
      top: -3px;
    }
    .help-icon:hover {
      opacity: 1;
    }
    .help-popover {
      position: absolute;
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      max-width: 100%;
      margin-top: 8px;
      display: none;
      color: #000;
    }

    /* OCR Slide‚ÄêIn Panel (Right) as a normal flex child */
    #ocr-panel {
      width: 320px;
      background-color: #1a1a1a;
      border-radius: 8px;
      padding: 20px;
      height: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      overflow: visible; /* allow dropdown popups */
      display: none;     /* hidden by default */
      flex-direction: column;
      color: #fff;
      z-index: 10;
    }
    #ocr-panel.open {
      display: flex; /* show as flex child */
    }
    #ocr-panel-header {
      display: flex;
      justify-content: flex-end;
    }
    #ocr-close-btn {
      font-size: 20px;
      cursor: pointer;
    }
    #ocr-panel-body {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    #ocr-column-select {
      width: 100%;
      padding: 6px;
      font-size: 14px;
      border-radius: 4px;
      background-color: #333;
      color: #fff;
      border: 1px solid #444;
      position: relative;
      z-index: 1000;
    }
    .dark-label {
      font-size: 14px;
      margin-bottom: 4px;
    }
    #ocr-upload-area {
      border: 2px dashed #555;
      border-radius: 6px;
      padding: 5px;
      text-align: center;
      background: #fafafa;
      color: #000;
      position: relative;
      cursor: pointer;
    }
    #ocr-upload-area .upload-icon {
      margin-bottom: 8px;
      color: #555;
    }
    #ocr-upload-area input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    #ocr-status {
      font-size: 0.8rem;
      margin-top: 8px;
      color: #28a745;
      display: none;
    }
    /* Expand the preview area to use full OCR panel width and larger preview height */
    #ocr-image-preview {
      width: 100%;                          /* fill OCR panel width */
      max-width: 100%;                    
      max-height: 50vh;      /* larger preview height (1.5√ó) */
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;                     /* hide overflow */
      background-color: #222;               /* dark background */
      margin-top: 12px;
      /* border-radius removed to make preview square */
    }

    /* Scale the image to fit within that container */
    #ocr-image-preview img {
      max-width: 100%;
      max-height: 50vh;
      width: 100%;
      height: auto;
      display: block;
    }
    #ocr-process-btn {
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
    }
    #ocr-process-btn:disabled {
      background-color: #444;
      cursor: not-allowed;
    }

    /* --------------------- Responsive Behavior --------------------- */
    @media (max-width: 960px) {
      #table-and-ocr-wrapper {
        flex-direction: column;
      }
      #ocr-panel {
        position: fixed;
        width: 100%;
        right: -100%;
        top: 0;
        height: 100vh;
      }
      #ocr-panel.open {
        right: 0;
      }
      #handsontable-container {
        margin-right: 0;
      }
      #top-row-right {
        flex-wrap: wrap;
        gap: 8px;
      }
      #top-row-right button {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div id="hybrid-tool-container">
    <div id="main-container">
      <!-- Top Row Controls -->
      <div id="top-row-controls">
        <div id="top-row-left">
          <span id="tool-heading">Add child parts/BO</span>
        </div>
        <!-- #top-row-right removed -->
      </div>

      <!-- Table and OCR Panel Wrapper -->
      <div id="table-and-ocr-wrapper">
        <!-- Handsontable Area (Left) -->
        <div id="handsontable-container">
          <!-- Instructions bar above the table -->
          <div class="instructions">
            üî¢ &lt; 20 rows | üîç zoom &amp; sharp | üö´ no header
            <span id="help-icon" class="help-icon"><i data-lucide="info"></i></span>
            <div id="help-popover" class="help-popover">
              <strong>Good vs Bad Screenshot:</strong><br />
              <img src="sample-screenshot.png" style="width: 100%;" />
            </div>
          </div>
          <div id="table-action-buttons">
            <button id="extract-btn">Extract</button>
            <button id="submit-btn">Submit</button>
          </div>
          <!-- Handsontable placeholder (will be initialized via JS) -->
          <div id="hot" style="width: 100%; height: 400px;"></div>
        </div>

        <!-- OCR Slide-In Panel (Right) -->
        <div id="ocr-panel">
          <div id="ocr-panel-header">
            <span id="ocr-close-btn">√ó</span>
          </div>
          <div id="ocr-panel-body">
            <label for="ocr-column-select" class="dark-label">
              Select Mapping Column
            </label>
            <select id="ocr-column-select" required>
              <!-- <option value="">Select Mapping Column</option> -->
              <option value="Drawing Number">Drawing Number</option>
              <option value="Quantity">Quantity</option>
              <option value="Description">Description</option>
              <option value="Material">Material</option>
            </select>

            <div id="ocr-upload-area" class="upload-area">
              <div class="upload-icon"><i data-lucide="upload"></i></div>
              <div class="upload-label">Upload Image for OCR</div>
              <input type="file" id="ocr-input" accept="image/*" />
              <div class="file-status" id="ocr-status">‚úì Uploaded</div>
              <div id="ocr-image-preview"></div>
            </div>

            <button id="ocr-process-btn" disabled>Process</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚Äî‚Äî‚Äî Begin Existing JavaScript Logic ‚Äî‚Äî‚Äî -->
  <!-- (These <script> blocks are your original logic, left completely intact. 
       They include renderSpreadsheet(), addColumn(), sendDataToBackend(), OCR calls, etc.) -->

  <script>
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Global state & utility functions (unchanged from your original)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    let currentStep = 1; // (unused now that we've collapsed Step 1/2 into one hybrid view)

    // Column‚Äêto‚ÄêTitle mapping (used by renderSpreadsheet)
    const COLUMN_TITLES = {
      PartNumber: "Part Number",
      Quantity: "Quantity",
      Description: "Description",
      Material: "Material",
      "Matched Childpart": "Select Drawing Number",
      Type: "Type",
    };

    let spreadsheetData = [];
    let columnsList = [];
    let hot;
    let windowChildParts = []; // will hold dropdown options from backend

    // Fetch query-params (project, part, parentdrgnum) on load and fetch childParts
window.addEventListener("DOMContentLoaded", async () => {
  const urlParams = new URLSearchParams(window.location.search);
  const project = urlParams.get("project");
  const partNumber = urlParams.get("part");
  const parentDrgNum = urlParams.get("parentdrgnum");
  if (!project || !partNumber || !parentDrgNum) {
    alert("Missing required query params: project/part/parentdrgnum");
    // Do not return; always initialize table even if params are missing
  } else {
    try {
      const resp = await fetch(
        "https://ocr-table-extractor.onrender.com/fetch-drawings",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ project, part: partNumber }),
        }
      );
      const data = await resp.json();
      windowChildParts = data.rows.map((r) =>
        decodeURIComponent(r.drawingNumber || "")
      );
    } catch (err) {
      console.error("Error fetching drawing data:", err);
    }
  }
  // Always initialize Handsontable, even if fetch fails or params are missing
  initializeHandsontable();
});

    // Sequential character matching + best‚Äêmatch utility
    function sequentialCharacterMatch(part, child) {
      if (!part || !child) return 0;
      const p = part.trim().toUpperCase();
      const c = child.trim().toUpperCase();
      if (p === c) return 1.0;
      if (c.includes(p)) return 0.99;
      let i = 0,
        j = 0,
        matched = 0;
      while (i < p.length && j < c.length) {
        if (p[i] === c[j]) {
          matched++;
          i++;
        }
        j++;
      }
      const baseSim = matched / p.length;
      const lengthDiff = Math.abs(p.length - c.length);
      const penalty = lengthDiff > 1 ? (lengthDiff - 1) * 0.1 : 0;
      const sim = Math.max(0, baseSim - penalty);
      if (matched === p.length) return Math.max(0.85, sim);
      return sim;
    }

    function findBestSequentialMatch(partText, drawingNumbers) {
      if (!partText || !drawingNumbers.length) {
        return { bestMatch: { target: "", rating: 0 }, allMatches: [] };
      }
      const matches = drawingNumbers.map((d) => ({
        target: d,
        rating: sequentialCharacterMatch(partText, d),
      }));
      matches.sort((a, b) => b.rating - a.rating);
      return { bestMatch: matches[0], allMatches: matches };
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Initialize Handsontable with 3 rows + 2 empty rows
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function initializeHandsontable() {
      // On first load, we want 5 rows of empty objects, each with just the 4 columns:
      // ‚ÄúSelect Drawing Number‚Äù (key ‚ÄúMatched Childpart‚Äù), ‚ÄúQuantity‚Äù, ‚ÄúDescription‚Äù, ‚ÄúMaterial‚Äù.
      spreadsheetData = [];
      for (let i = 0; i < 5; i++) {
        spreadsheetData.push({
          "Matched Childpart": "",
          Quantity: { text: "", confidence: 0 },
          Description: { text: "", confidence: 0 },
          Material: { text: "", confidence: 0 },
        });
      }

      // Only the 4 columns initially: mapping + 3 OCR
      columnsList = [
        "Matched Childpart",
        "Quantity",
        "Description",
        "Material",
      ];

      renderSpreadsheet();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // renderSpreadsheet (combines OCR columns + mapping columns in one view)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function renderSpreadsheet() {
      // Prepare column definitions for Handsontable
      const drawingOptions = windowChildParts.slice(); // from fetched backend
      const columns = columnsList.map((key) => {
        const title = COLUMN_TITLES[key] || key;
        const isMatched = key === "Matched Childpart";
        const isType = key === "Type";
        const isOCRcol = ["PartNumber", "Quantity", "Description", "Material"].includes(
          key
        );

        return {
          data: isMatched || isType ? key : `${key}.text`,
          title,
          type: isMatched || isType ? "dropdown" : "text",
          editor: isMatched
            ? "autocomplete"
            : isType
            ? "dropdown"
            : "text",
          source: isMatched
            ? ["", ...drawingOptions]
            : isType
            ? ["", "Child Part", "BO"]
            : undefined,
          strict: false,
          allowInvalid: true,
          readOnly: false, // all columns remain editable
          renderer: function (hotInstance, td, row, col, prop, value, cellProps) {
            if (isMatched || isType) {
              // dropdown renderer for mapping columns
              Handsontable.renderers.DropdownRenderer.apply(this, arguments);
              if (isMatched && value && value.toString().trim() !== "") {
                // low‚Äêsimilarity warning on mapping in real time
                const rowData = hotInstance.getSourceDataAtRow(row);
                const partCell = rowData["PartNumber"];
                const partText = partCell?.text || "";
                if (partText) {
                  const sim = sequentialCharacterMatch(partText, value.toString());
                  if (sim < 0.95) {
                    td.classList.add("low-similarity-cell");
                  } else {
                    td.classList.remove("low-similarity-cell");
                  }
                }
              } else {
                td.classList.remove("low-similarity-cell");
              }
            } else {
              // OCR columns: color by confidence
              Handsontable.renderers.TextRenderer.apply(this, arguments);
              const rowData = hotInstance.getSourceDataAtRow(row);
              const cellObj = rowData[key];  // the { text, confidence } you stored

              if (cellObj && typeof cellObj === "object") {
                const conf = parseFloat(cellObj.confidence || 0);
                // Only apply a background if confidence > 0;
                // otherwise leave it blank (white).
                if (conf > 0) {
                  if (conf >= 0.95) {
                    td.style.backgroundColor = "rgba(76, 175, 80, 0.2)";
                  } else if (conf >= 0.8) {
                    td.style.backgroundColor = "rgba(255, 152, 0, 0.2)";
                  } else {
                    td.style.backgroundColor = "rgba(244, 67, 54, 0.2)";
                  }
                } else {
                  // No coloring when confidence is zero (empty cell)
                  td.style.backgroundColor = "";
                }
              }
            }
          },
        };
      });

      // Destroy any existing Handsontable instance
      const container = document.getElementById("hot");
      if (hot) {
        hot.destroy();
      }

      // Re‚Äêcreate with our new columns + data
      hot = new Handsontable(container, {
        data: spreadsheetData,
        columns,
        colHeaders: columnsList.map((k) => COLUMN_TITLES[k]),
        rowHeaders: true,
        minSpareRows: 1,
        contextMenu: ["remove_row", "copy", "paste"],
        dropdownMenu: true,
        filters: true,
        autoColumnSize: true,
        outsideClickDeselects: true,
        licenseKey: "non-commercial-and-evaluation",
        afterSelectionEnd: function (r, c, r2, c2) {
          setTimeout(() => {
            document
              .querySelectorAll('.wtBorder.current[style*="display: block"]')
              .forEach((border) => {
                const style = border.getAttribute("style");
                if (style.includes("width: 4px")) {
                  border.setAttribute("style", style.replace("width: 4px", "width: 1px"));
                }
                if (style.includes("height: 4px")) {
                  border.setAttribute("style", style.replace("height: 4px", "height: 1px"));
                }
              });
          }, 0);
        },
      });

      // Re‚Äêattach the ‚ÄúafterChange‚Äù hook to mark edited cells & auto‚Äêpopulate ‚ÄúType‚Äù
      hot.addHook("afterChange", (changes, source) => {
        if (source !== "edit" || !changes) return;
        changes.forEach(([row, prop, oldVal, newVal]) => {
          if (oldVal === newVal) return;
          const colIndex = hot.propToCol(prop);
          hot.setCellMeta(row, colIndex, "className", "edited-cell");

          // If user changed ‚ÄúMatched Childpart‚Äù, auto‚Äêpopulate ‚ÄúType‚Äù
          if (prop === "Matched Childpart") {
            const typeColIdx = hot.propToCol("Type");
            if (typeColIdx !== -1) {
              if (newVal && newVal.toString().trim() !== "") {
                hot.setDataAtCell(row, typeColIdx, "Child Part", "auto-type-population");
              } else {
                hot.setDataAtCell(row, typeColIdx, "BO", "auto-type-population");
              }
            }
          }
        });
        hot.render();
      });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // addColumn: used by OCR processing to inject a new column's OCR data
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function addColumn(newColumnData, label) {
      // If label already in columnsList, remove existing column entry & data
      const existingIdx = columnsList.indexOf(label);
      if (existingIdx > -1) {
        columnsList.splice(existingIdx, 1);
        spreadsheetData.forEach((row) => {
          delete row[label];
        });
      }
      // Push label at the end
      columnsList.push(label);

      // If OCR for PartNumber arrives, also inject mapping columns:
      if (label === "PartNumber" && !columnsList.includes("Matched Childpart")) {
        columnsList.push("Matched Childpart");
        columnsList.push("Type");
      }

      // Write data into spreadsheetData
      for (let i = 0; i < newColumnData.length; i++) {
        const text = newColumnData[i].text || "";
        const confidence = newColumnData[i].confidence || 0;
        if (!spreadsheetData[i]) spreadsheetData[i] = {};
        spreadsheetData[i][label] = { text: text, confidence: confidence };

        // If injecting PartNumber, auto‚Äêcompute a match & Type
        if (label === "PartNumber") {
          const drawingMatches = windowChildParts.slice();
          const best = findBestSequentialMatch(text, drawingMatches);
          const matchText = best.bestMatch.rating > 0.85 ? best.bestMatch.target : "";
          spreadsheetData[i]["Matched Childpart"] = matchText;
          spreadsheetData[i]["_similarityScore"] = best.bestMatch.rating;
          spreadsheetData[i]["Type"] = matchText ? "Child Part" : "BO";
        }
      }

      renderSpreadsheet();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // OCR Processing Handler: triggered when user clicks ‚ÄúProcess‚Äù in OCR panel
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.getElementById("ocr-process-btn").addEventListener("click", async () => {
      console.log("OCR ‚Üí Process button clicked, column=", document.getElementById("ocr-column-select").value);

      const selectedColumn = document.getElementById("ocr-column-select").value;
      const fileInput = document.getElementById("ocr-input");
      if (!selectedColumn || !fileInput.files[0]) return;

      // Visual feedback: disable button & show status icon
      const processBtn = document.getElementById("ocr-process-btn");
      processBtn.disabled = true;
      document.getElementById("ocr-status").style.display = "inline-block";

      // Package to FormData
      const formData = new FormData();
      formData.append("image", fileInput.files[0]);
      formData.append("mode", "table");
      // Map our displayed label back to the correct column key in code:
      let columnKey = "";
      if (selectedColumn === "Drawing Number") columnKey = "Matched Childpart";
      else if (selectedColumn === "Quantity") columnKey = "Quantity";
      else if (selectedColumn === "Description") columnKey = "Description";
      else if (selectedColumn === "Material") columnKey = "Material";

      formData.append("column", columnKey);

      try {
        const resp = await fetch("https://ocr-table-extractor.onrender.com", {
          method: "POST",
          body: formData,
        });
        const data = await resp.json();
        if (data.table && Array.isArray(data.table)) {
          addColumn(data.table, columnKey);
        } else {
          console.warn("OCR returned no table data for column:", columnKey);
        }
      } catch (err) {
        console.error("‚ùå Error during OCR processing:", err);
      } finally {
        // Hide status after a moment and re-enable UI
        setTimeout(() => {
          document.getElementById("ocr-status").style.display = "none";
          processBtn.disabled = true;
          // Clear file input for next time
          fileInput.value = "";
        }, 1500);
      }
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // OCR UI: Enable ‚ÄúProcess‚Äù button only when a column is selected & file present
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const ocrSelect = document.getElementById("ocr-column-select");
    const ocrInput = document.getElementById("ocr-input");
    function updateOcrProcessState() {
      const hasCol = !!ocrSelect.value;
      const hasFile = !!ocrInput.files.length;
      document.getElementById("ocr-process-btn").disabled = !(hasCol && hasFile);
    }
    ocrSelect.addEventListener("change", updateOcrProcessState);
    ocrInput.addEventListener("change", () => {
      const status = document.getElementById("ocr-status");
      const preview = document.getElementById("ocr-image-preview");
      if (ocrInput.files[0]) {
        status.style.display = "inline-block";
        const reader = new FileReader();
        reader.onload = function (e) {
          preview.innerHTML = `<img src="${e.target.result}" alt="Preview"/>`;
        };
        reader.readAsDataURL(ocrInput.files[0]);
      } else {
        status.style.display = "none";
        preview.innerHTML = "";
      }
      updateOcrProcessState();
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // OCR Panel Toggle: Extract button opens, Close (X) closes
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.getElementById("extract-btn").addEventListener("click", () => {
      const panel = document.getElementById("ocr-panel");
      panel.style.display = "flex";
      setTimeout(() => {
        panel.classList.add("open");

        // Logic to auto-select Mapping Column based on empty columns
        const priority = ["Matched Childpart", "Quantity", "Description", "Material"];
        let autoSelect = "";
        for (let col of priority) {
          let isEmpty = spreadsheetData.every((row) => {
            const val = row[col];
            if (!val) return true;
            if (typeof val === "object") return !val.text;
            return val.trim() === "";
          });
          if (isEmpty) {
            if (col === "Matched Childpart") autoSelect = "Drawing Number";
            else autoSelect = col;
            break;
          }
        }
        const select = document.getElementById("ocr-column-select");
        if (select) {
          for (let opt of select.options) {
            if (opt.value === autoSelect) {
              opt.selected = true;
              break;
            }
          }
        }
        updateOcrProcessState();
      }, 10);
    });
    document.getElementById("ocr-close-btn").addEventListener("click", () => {
      const panel = document.getElementById("ocr-panel");
      panel.classList.remove("open");
      setTimeout(() => {
        panel.style.display = "none";
      }, 300);
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Show/Hide help popover
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.getElementById("help-icon").addEventListener("click", () => {
      const pop = document.getElementById("help-popover");
      pop.style.display = pop.style.display === "none" ? "block" : "none";
    });
    document.addEventListener("click", (e) => {
      if (!e.target.closest("#help-icon")) {
        document.getElementById("help-popover").style.display = "none";
      }
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ÄúSubmit‚Äù button simply calls your existing sendDataToBackend()
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.getElementById("submit-btn").addEventListener("click", () => {
      sendDataToBackend();
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Existing sendDataToBackend() function (unchanged from your original)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function sendDataToBackend() {
      const addDataBtn = document.getElementById("submit-btn");
      const originalText = addDataBtn.textContent;
      try {
        // Provide some visual feedback (you can customize as needed)
        addDataBtn.disabled = true;
        addDataBtn.textContent = "Sending...";
        // Validate required fields:
        const validation = validateRequiredFields();
        if (!validation.isValid) {
          alert(
            `Missing Required Fields:\n${validation.missingFields.join(
              ", "
            )}\nRequired fields:\n- Part Number, Quantity, Type (always required)\n- Select Drawing Number if Type = ‚ÄúChild Part‚Äù`
          );
          addDataBtn.textContent = originalText;
          return;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const project = urlParams.get("project");
        const parentDrawingNumber = urlParams.get("parentdrgnum");
        const partNumber = urlParams.get("part");
        if (!project || !parentDrawingNumber || !partNumber) {
          throw new Error("Missing required URL params");
        }

        // Build ChildParts & BO arrays
        const childPartsData = [];
        const boData = [];
        spreadsheetData.forEach((row) => {
          const frontendPN = row.PartNumber?.text?.trim();
          const qty = row.Quantity?.text?.trim();
          const type = row.Type?.trim();
          if (!frontendPN && !qty) return;
          if (!frontendPN || !qty || !type) return;
          if (type === "Child Part") {
            childPartsData.push({
              quantity: qty,
              description: row.Description?.text?.trim() || "",
              material: row.Material?.text?.trim() || "",
              drawingNumber: row["Matched Childpart"] || "",
            });
          } else if (type === "BO") {
            const matched = row["Matched Childpart"]?.trim();
            boData.push({
              quantity: qty,
              description: row.Description?.text?.trim() || "",
              material: row.Material?.text?.trim() || "",
              boughtoutPartNumber: matched || frontendPN,
            });
          }
        });

        let successful = 0,
          total = 0;
        if (childPartsData.length) {
          total++;
          const respChild = await fetch(
            "https://ocr-table-extractor.onrender.com/add-child-parts",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                rows: childPartsData,
                project,
                parentDrawingNumber,
                partNumber,
              }),
            }
          );
          if (!respChild.ok) {
            throw new Error(`Failed to add Child Parts: ${await respChild.text()}`);
          }
          successful++;
        }
        if (boData.length) {
          total++;
          const respBo = await fetch(
            "https://ocr-table-extractor.onrender.com/add-bo-parts",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                rows: boData,
                project,
                parentDrawingNumber,
                partNumber,
              }),
            }
          );
          if (!respBo.ok) {
            throw new Error(`Failed to add BO Parts: ${await respBo.text()}`);
          }
          successful++;
        }

        if (successful === total && total > 0) {
          alert(
            `Data added successfully!\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}`
          );
        } else {
          throw new Error("No data was processed");
        }
      } catch (error) {
        console.error("‚ùå Error sending data:", error);
        alert(`Error adding data: ${error.message}`);
      } finally {
        addDataBtn.disabled = false;
        addDataBtn.textContent = "Submit";
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // validateRequiredFields (unchanged)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function validateRequiredFields() {
      const missingFields = [];
      let hasValidRow = false;
      spreadsheetData.forEach((row, index) => {
        const partPN = row.PartNumber?.text?.trim();
        const qty = row.Quantity?.text?.trim();
        const type = row.Type?.trim();
        if (!partPN && !qty) return;
        hasValidRow = true;
        if (!partPN) missingFields.push(`Row ${index + 1}: Part Number`);
        if (!qty) missingFields.push(`Row ${index + 1}: Quantity`);
        if (!type) missingFields.push(`Row ${index + 1}: Type`);
        if (type === "Child Part" && !row["Matched Childpart"]) {
          missingFields.push(`Row ${index + 1}: Select Drawing Number`);
        }
      });
      return { isValid: hasValidRow && missingFields.length === 0, missingFields };
    }
  </script>
  <!-- ‚Äî‚Äî‚Äî End Existing JavaScript Logic ‚Äî‚Äî‚Äî -->
</body>
</html>
